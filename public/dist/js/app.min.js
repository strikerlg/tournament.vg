(function() {
    'use strict';

    angular
        .module('vg.app', [
            /* Angular modules */
            'ngAnimate',
            /* App modules */
            /* Third-party modules */
            'ui.router',
            'firebase',
            'validation.match',
            'ordinal',
            'ngFileUpload',
            'ngImgur'
        ]);
})();;(function() {
	'use strict';

	angular
		.module('vg.app')
		.constant('FIREBASEDATA', {
			'FBURL': 'https://wolfscontests.firebaseio.com'
		})
		.config(config);

	/* @ngInject */
	function config($stateProvider, $urlRouterProvider) {

		// Redirect any unmatched URL to /.
		$urlRouterProvider.otherwise('/');

		$stateProvider
		    .state('home', {
		    	url: '/',
		    	templateUrl: 'app/home/home.htm',
		    	controller: 'HomeController as home'
		    })

		    .state('registerOrLogin', {
		    	url: '/registerOrLogin',
		    	templateUrl: '/app/home/reg.htm',
		    	controller: 'RegController as reg'
		    })

		    .state('profile', {
		    	url: '/profile/:username',
		    	templateUrl: '/app/home/profile.htm',
		    	controller: 'ProfileController as profile'
		    })

		    .state('leaderboard', {
		    	url: '/leaderboard',
		    	templateUrl: '/app/home/leaderboard.htm',
		    	controller: 'LeaderboardController as leaderboard'
		    })

		    .state('event', {
		    	url: '/event/:eventName/main',
		    	templateUrl: '/app/event/main.htm',
		    	controller: 'EventMainController as event'
		    })

		    .state('customizeAvatar', {
		    	url: '/customizeAvatar',
		    	templateUrl: '/app/home/avatar.htm',
		    	controller: 'AvatarController as avatar',

		    	resolve: {
		    		'currentAuth': ['AuthWrapper', function(AuthWrapper) {
		    			return AuthWrapper.$requireAuth();
		    		}]
		    	}
		    })

		    .state('changePassword', {
		    	url: '/changePassword',
		    	templateUrl: '/app/home/changePassword.htm',
		    	controller: 'ChangePasswordController as pwchange',

		    	resolve: {
		    		'currentAuth': ['AuthWrapper', function(AuthWrapper) {
		    			return AuthWrapper.$requireAuth();
		    		}]
		    	}
		    });
	}
	config.$inject = ["$stateProvider", "$urlRouterProvider"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .run(run);

    function run($rootScope, $location, $state, $firebaseObject, AuthWrapper, FIREBASEDATA) {

        $rootScope.$on('$stateChangeError', function(event, toState, toParams, fromState, fromParams, error) {
            if (error === 'AUTH_REQUIRED') {
                $state.go('registerOrLogin');
            }
        });

        $rootScope.$on('$stateChangeSuccess', function() {

            // If user is logged in, download their profile data to an object in $rootScope.
            // FIXME: We shouldn't need to do this every successful state change.
            if (AuthWrapper.$getAuth()) {
                
                var authData = AuthWrapper.$getAuth();
                var ref = new Firebase(FIREBASEDATA.FBURL);

                var profileData = $firebaseObject(ref.child('users').child(authData.uid));
                profileData.$bindTo($rootScope, 'profile').then(function(unbind) {
                    $rootScope.unbindFunction = unbind;
                });

            }

        });

        $rootScope.Utils = {
            keys: Object.keys
        };

    }
    run.$inject = ["$rootScope", "$location", "$state", "$firebaseObject", "AuthWrapper", "FIREBASEDATA"];

})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .service('authService', authService);

    /* @ngInject */
    function authService($q, $rootScope, $state, $window, $timeout, $firebaseObject, AuthWrapper, FIREBASEDATA) {
        
        this.testData = 'hello world!';

    	this.checkIfUserExists = checkIfUserExists;
    	this.createNewUser = createNewUser;
        this.loginToAccount = loginToAccount;
        this.logOut = logOut;

    	///////////////////

    	function checkIfUserExists(inputUsername) {

    		var deferred = $q.defer();

    		var doesUserExist = false;
    		var usersRef = new $window.Firebase(FIREBASEDATA.FBURL + '/users');

    		usersRef.once('value', function(dataSnapshot) {

                $timeout(function() {
                    dataSnapshot.forEach(function(user) {
                        if (user.val().userName === inputUsername) {
                            doesUserExist = true;
                        }
                    });

                    deferred.resolve(doesUserExist);
                });

    		});

    		return deferred.promise;

    	}

    	function createNewUser(inputEmail, inputPassword, inputUsername) {

            var deferred = $q.defer();

    		AuthWrapper.$createUser({
    			email: inputEmail,
    			password: inputPassword
    		}).then(function(userData) {

    			// Create a data entry for the new username.
    			new Firebase(FIREBASEDATA.FBURL).child('users/' + userData.uid).set({

    				userName: inputUsername,
    				role: 'User'

    			}, function(errorData) {
    				console.error(errorData);
                    return errorData.code;
    			});

                // Create a data entry for the user's avatar.
                new Firebase(FIREBASEDATA.FBURL).child('avatars').child(inputUsername).set('http://api.adorable.io/avatars/42/' + inputUsername);

    			// Log the user in.
    			AuthWrapper.$authWithPassword({
    				email: inputEmail,
    				password: inputPassword
    			}).then(function() {
                    deferred.resolve('ACCOUNT_CREATED');
                });

    		}).catch(function(errorData) {

    			console.error(errorData);

    			if (errorData.code === 'EMAIL_TAKEN') {
                    deferred.resolve(errorData.code);
    			}

    		});

            return deferred.promise;

    	}

        function loginToAccount(inputEmail, inputPassword) {

            var deferred = $q.defer();

            AuthWrapper.$authWithPassword({
                email: inputEmail,
                password: inputPassword
            }).then(function(authData) {

                deferred.resolve('LOGIN_SUCCESS');

            }).catch(function(errorData) {

                if (errorData.code === 'INVALID_USER') {
                    deferred.resolve('INVALID_USER');
                } else if (errorData.code === 'INVALID_PASSWORD') {
                    deferred.resolve('INVALID_PASSWORD');
                }

            });

            return deferred.promise;

        }

        function logOut() {
            AuthWrapper.$unauth();
            $rootScope.unbindFunction();
        }

    }
    authService.$inject = ["$q", "$rootScope", "$state", "$window", "$timeout", "$firebaseObject", "AuthWrapper", "FIREBASEDATA"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .factory('AuthWrapper', AuthWrapper);

    /* @ngInject */
    function AuthWrapper($firebaseAuth, FIREBASEDATA) {

        var ref = new Firebase(FIREBASEDATA.FBURL);
        return $firebaseAuth(ref);

    }
    AuthWrapper.$inject = ["$firebaseAuth", "FIREBASEDATA"];
    
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .service('eventService', eventService);

    /* @ngInject */
    function eventService($q, $filter, $rootScope, $firebaseObject, $firebaseArray, FIREBASEDATA, teamService) {

        var _eventProperties = null;
        var _gameList = null;
        var _leaderboardLength = null;
        var _summarizedLeaderboard = null;
        var _teamLeaderboardLength = null;
        var _teamSummarizedLeaderboard = null;
        var _teamList = null;

        this.addGame = addGame;
        this.createMultiGameFinalStandings = createMultiGameFinalStandings;
        this.getEventProperties = getEventProperties;
        this.getEventPropertiesObject = getEventPropertiesObject;
        this.getGameData = getGameData;
        this.getGameListObject = getGameListObject;
        this.getGamesList = getGamesList;
        this.getLeaderboardLengthValue = getLeaderboardLengthValue;
        this.getMultiGameLeaderboard = getMultiGameLeaderboard;
        this.getPlayerScores = getPlayerScores;
        this.getPlayerTeamScores = getPlayerTeamScores;
        this.getPlayerPool = getPlayerPool;
        this.getSingleGameLeaderboard = getSingleGameLeaderboard;
        this.getSummarizedLeaderboardObject = getSummarizedLeaderboardObject;
        this.getTeamBasedMultiGamePlayerLeaderboard = getTeamBasedMultiGamePlayerLeaderboard;
        this.getTeamGameScores = getTeamGameScores;
        this.getTeamLeaderboardLengthValue = getTeamLeaderboardLengthValue;
        this.getTeamListObject = getTeamListObject;
        this.getTeamSummarizedLeaderboardObject = getTeamSummarizedLeaderboardObject;
        this.loadEventProperties = loadEventProperties;
        this.submitTeamBasedRegistration = submitTeamBasedRegistration;
        this.submitTeamMultiGameScore = submitTeamMultiGameScore;

        ////////////////

        function addGame(inputEvent, inputFormalGameName, inputMameRomset, inputRules) {

            return $q(function(resolve, reject) {

                var newGame = {
                    name: inputFormalGameName,
                    mameSet: inputMameRomset,
                    rules: inputRules
                };

                _gameList.$add(newGame);

                resolve();

            });

        }

        function createMultiGameFinalStandings(inputEvent) {

            // Calculate the final standings of the event.
            getMultiGameLeaderboard(inputEvent).then(function then(model) {

                var ref = new Firebase(FIREBASEDATA.FBURL);
                var inputEventStandings = $firebaseObject(
                    ref
                        .child('standings')
                        .child(inputEvent)
                );

                inputEventStandings.$loaded().then(function() {

                    model.forEach(function(standing) {
                        inputEventStandings[standing.key] = standing.position;
                    });

                    inputEventStandings.$save();

                });

            });

        }

        function getEventProperties(inputEvent) {

            var deferred = $q.defer();

        	var ref = new Firebase(FIREBASEDATA.FBURL);
        	var eventProperties = $firebaseObject(
        		ref
        			.child('contests')
        			.child(inputEvent)
        			.child('properties')
        	);

            deferred.resolve(eventProperties);

        	return deferred.promise;

        }

        function getEventPropertiesObject() {
            return _eventProperties;
        }

        function getFirstPlaceScores() {

            _gameList.forEach(function(game) {

                // If there are scores, get the top one.
                if (game.scores) {

                    var scoresArray = $.map(game.scores, function(el) { return el; });
                    scoresArray = $filter('orderBy')(scoresArray, '-score');
                    game.firstScore = scoresArray[0];

                }

            });

        }

        function getGameData(inputEvent, inputGame) {

            var deferred = $q.defer();

            var ref = new Firebase(FIREBASEDATA.FBURL);

            getGamesList(inputEvent).then(function(gamesList) {

                gamesList.forEach(function(game) {

                    if (game.name === inputGame) {
                        deferred.resolve(game);
                    }

                });

            });

            return deferred.promise;

        }

        function getGameListObject() {
            return _gameList;
        }

        function getGamesList(inputEvent) {

        	var deferred = $q.defer();

        	var ref = new Firebase(FIREBASEDATA.FBURL);
        	var gamesList = $firebaseArray(
        		ref
        			.child('contests')
        			.child(inputEvent)
        			.child('activeGames')
        	);

        	gamesList.$loaded().then(function() {
        		deferred.resolve(gamesList);
        	});

        	return deferred.promise;

        }

        function getLeaderboardLengthValue() {
            return _leaderboardLength;
        }

        function getMultiGameLeaderboard(inputEvent) {

        	var deferred = $q.defer();

        	// We need to get the top 12 players for every game.
        	var playerPoints = {};

        	getGamesList(inputEvent).then(function then(model) {

        		var gamesList = model;
        		gamesList.forEach(function(game) {

        			if (game.scores) {

        				// Convert the game's scores to an array.
        				var scoresArray = $.map(game.scores, function(el) { return el; });
        				scoresArray = $filter('orderBy')(scoresArray, '-score');

        				var totalAward = 12;

        				// Iterate through the top scores awarding points.
        				for (var i = 0; i < scoresArray.length; i++) {

        					if (!playerPoints[scoresArray[i].userName]) {
        						playerPoints[scoresArray[i].userName] = {
        							points: 0
        						};
        					}

        					playerPoints[scoresArray[i].userName].points += totalAward;

        					if (totalAward > 0) {
        						totalAward -= 1;
        					}

        				}

        			}

        		});

        		// Find and resolve ties.
        		playerPoints = $filter('orderObjectBy')(playerPoints, 'points', true);
                var haveBottomScorersFloor = false;
                var floorRange = 0;
        		for (var i = 0; i < playerPoints.length; i += 1) {

        			if (playerPoints[i-1] && playerPoints[i].points && playerPoints[i-1].points) {

        				if (playerPoints[i].points === playerPoints[i-1].points) {
        					playerPoints[i].position = playerPoints[i-1].position;
        				} else {
        					playerPoints[i].position = (i+1);
        				}

        			} else {

        				if (i === 0) {
        					playerPoints[i].position = 1;
        				} else {

                            if (!haveBottomScorersFloor) {
                                // Get count of players in one position higher.
                                var getScoreCountOf = playerPoints[i-1].points;

                                for (var j = 0; j < playerPoints.length; j += 1) {
                                    if (playerPoints[j].points === getScoreCountOf) {
                                        floorRange += 1;
                                    }
                                }

                                haveBottomScorersFloor = true;
                            }

        					playerPoints[i].position = (playerPoints.length + 1) - floorRange;
        				}

        			}

        		}

        		deferred.resolve(playerPoints);

        	});

			return deferred.promise;

        }

        function getSingleGameLeaderboard(inputEvent) {

            var deferred = $q.defer();

            var ref = new Firebase(FIREBASEDATA.FBURL);
            var leaderboardData = $firebaseArray(
                ref
                    .child('contests')
                    .child(inputEvent)
                    .child('scores')
            );

            deferred.resolve(leaderboardData);

            return deferred.promise;

        }

        function getSummarizedLeaderboardObject() {
            return _summarizedLeaderboard;
        }

        function getTeamBasedMultiGamePlayerLeaderboard(inputEvent) {

            return $q(function(resolve, reject) {

                var playerPoints = {};
                _gameList.forEach(function(game) {

                    if (game.scores) {

                        var scoresArray = $.map(game.scores, function(el) { return el; });
                        scoresArray = $filter('orderBy')(scoresArray, '-score');
                        var totalAward = _teamList.length * 5;
                        var teamTracker = {};

                        for (var i = 0; i < scoresArray.length; i++) {

                            if (!teamTracker[scoresArray[i].team]) {
                                teamTracker[scoresArray[i].team] = 1;
                            } else {
                                teamTracker[scoresArray[i].team] += 1;
                            }

                            if (!playerPoints[scoresArray[i].userName]) {
                                playerPoints[scoresArray[i].userName] = {
                                    points: 0
                                };
                            }

                            if (teamTracker[scoresArray[i].team] <= 5) {

                                playerPoints[scoresArray[i].userName].points += totalAward;
                                playerPoints[scoresArray[i].userName].team = scoresArray[i].team;

                                if (totalAward > 0) {
                                    totalAward -= 1;
                                }

                            }

                        }

                    }

                });

                playerPoints = $filter('orderObjectBy')(playerPoints, 'points', true);
                resolve(playerPoints);

            });

        }

        function getTeamGameScores(inputEvent, inputTeam) {

            return $q(function(resolve, reject) {

                var playerPoints = {};
                var teamPoints = {};
                var gamePoints = [];

                _gameList.forEach(function(game) {

                    if (game.scores) {

                        var scoresArray = $.map(game.scores, function(el) { return el; });
                        scoresArray = $filter('orderBy')(scoresArray, '-score');
                        var totalAward = _teamList.length * 5;
                        var teamTracker = {};

                        for (var i = 0; i < scoresArray.length; i++) {

                            if (!teamTracker[scoresArray[i].team]) {
                                teamTracker[scoresArray[i].team] = 1;
                            } else {
                                teamTracker[scoresArray[i].team] += 1;
                            }

                            if (!teamPoints[scoresArray[i].team]) {
                                teamPoints[scoresArray[i].team] = {
                                    points: 0
                                };
                            }

                            if (teamTracker[scoresArray[i].team] <= 5) {

                                teamPoints[scoresArray[i].team].points += totalAward;

                                if (totalAward > 0) {
                                    totalAward -= 1;
                                }

                            }

                        }

                        gamePoints.push({
                            name: game.name,
                            camelName: game.camelName,
                            points: (teamPoints[inputTeam] && teamPoints[inputTeam].points) ? teamPoints[inputTeam].points : 0
                        });

                        if (teamPoints[inputTeam] && teamPoints[inputTeam].points) {
                            teamPoints[inputTeam].points = 0;
                        }

                    }

                });

                teamPoints = $filter('orderObjectBy')(teamPoints, 'points', true);
                resolve(gamePoints);

            });

        }

        function getTeamLeaderboard(inputEvent) {

            return $q(function(resolve, reject) {

                var playerPoints = {};
                var teamPoints = {};
                _gameList.forEach(function(game) {

                    if (game.scores) {

                        var scoresArray = $.map(game.scores, function(el) { return el; });
                        scoresArray = $filter('orderBy')(scoresArray, '-score');
                        var totalAward = _teamList.length * 5;
                        var teamTracker = {};

                        for (var i = 0; i < scoresArray.length; i++) {

                            if (!teamTracker[scoresArray[i].team]) {
                                teamTracker[scoresArray[i].team] = 1;
                            } else {
                                teamTracker[scoresArray[i].team] += 1;
                            }

                            if (!teamPoints[scoresArray[i].team]) {
                                teamPoints[scoresArray[i].team] = {
                                    points: 0
                                };
                            }

                            if (teamTracker[scoresArray[i].team] <= 5) {

                                teamPoints[scoresArray[i].team].points += totalAward;

                                if (totalAward > 0) {
                                    totalAward -= 1;
                                }

                            }

                        }

                    }

                });

                teamPoints = $filter('orderObjectBy')(teamPoints, 'points', true);

                // Get the full name of the teams.
                teamPoints.forEach(function(team) {

                    // Find this team in the teamList array.
                    _teamList.forEach(function(completeTeam) {

                        if (team.key === completeTeam.$id) {
                            team.fullName = completeTeam.fullName;
                        }

                    });

                });

                resolve(teamPoints);

            });

        }

        function getTeamListObject() {
            return _teamList;
        }

        function getPlayerPool(inputEvent) {

            var deferred = $q.defer();

            var ref = new Firebase(FIREBASEDATA.FBURL);
            var playerPoolData = $firebaseObject(
                ref
                    .child('contests')
                    .child(inputEvent)
                    .child('playerPool')
            );

            deferred.resolve(playerPoolData);

            return deferred.promise;

        }

        function getPlayerTeamScores(inputEvent, inputGamesList, inputPlayer) {

            return $q(function(resolve, reject) {

                var displayScores = [];
                var playerPoints = {};
                var teamTracker = {};

                // Iterate through every game.
                inputGamesList.forEach(function(game) {

                    if (game.scores) {

                        var scoresArray = $.map(game.scores, function(el) { return el; });
                        scoresArray = $filter('orderBy')(scoresArray, '-score');
                        var totalAward = _teamList.length * 5;
                        var teamTracker = {};

                        for (var i = 0; i < scoresArray.length; i++) {

                            if (!teamTracker[scoresArray[i].team]) {
                                teamTracker[scoresArray[i].team] = 1;
                            } else {
                                teamTracker[scoresArray[i].team] += 1;
                            }

                            if (!playerPoints[scoresArray[i].userName]) {
                                playerPoints[scoresArray[i].userName] = {
                                    points: 0
                                };
                            }

                            if (scoresArray[i].userName === inputPlayer) {

                                var newScoreObject = {};
                                newScoreObject.position = i+1;
                                newScoreObject.name = game.name;
                                newScoreObject.team = scoresArray[i].team;
                                newScoreObject.score = scoresArray[i].score;
                                newScoreObject.inpUrl = scoresArray[i].inpUrl ? scoresArray[i].inpUrl : null;
                                newScoreObject.twitchUrl = scoresArray[i].twitchUrl ? scoresArray[i].twitchUrl : null;
                                newScoreObject.screenshotUrl = scoresArray[i].screenshotUrl ? scoresArray[i].screenshotUrl : null;
                                newScoreObject.mameVersion = scoresArray[i].mameVersion ? scoresArray[i].mameVersion : null;

                                if (teamTracker[scoresArray[i].team] <= 5) {
                                    newScoreObject.pointsEarned = totalAward;
                                } else {
                                    newScoreObject.pointsEarned = 0;
                                }

                                displayScores.push(newScoreObject);

                            } else {
                                totalAward -= 1;
                            }

                        }

                    }

                });

                resolve(displayScores);

            });

        }

        function getPlayerScores(inputEvent, inputGamesList, inputPlayer) {

            var deferred = $q.defer();

            var displayScores = [];

            // Iterate through every game.
            inputGamesList.forEach(function(game) {

                if (game.scores) {

                    // Convert the game's scores to an array.
                    var scoresArray = $.map(game.scores, function(el) { return el; });
                    scoresArray = $filter('orderBy')(scoresArray, '-score');

                    var totalAward = 12;

                    // Iterate through the scores starting from the top and find our user.
                    for (var i = 0; i < scoresArray.length; i++) {

                        // Found our player.
                        if (scoresArray[i].userName === inputPlayer) {

                            var newScoreObject = game;
                            newScoreObject.position = i+1;
                            newScoreObject.score = scoresArray[i].score;
                            newScoreObject.pointsEarned = totalAward;
                            newScoreObject.inpUrl = scoresArray[i].inpUrl ? scoresArray[i].inpUrl : null;
                            newScoreObject.twitchUrl = scoresArray[i].twitchUrl ? scoresArray[i].twitchUrl : null;
                            newScoreObject.mameVersion = scoresArray[i].mameVersion ? scoresArray[i].mameVersion : null;

                            displayScores.push(newScoreObject);
                            totalAward = 12;
                            break;

                        } else {
                            if (totalAward > 0) {
                                totalAward -= 1;
                            }
                        }

                    }

                }

            });

            deferred.resolve(displayScores);

            return deferred.promise;

        }

        function getTeamLeaderboardLengthValue() {
            return _teamLeaderboardLength;
        }

        function getTeamSummarizedLeaderboardObject() {
            return _teamSummarizedLeaderboard;
        }

        function loadEventProperties(inputEvent) {

            var ref = new Firebase(FIREBASEDATA.FBURL);
            var inputEventProperties = $firebaseObject(
                ref
                    .child('contests')
                    .child(inputEvent)
                    .child('properties')
            );

            inputEventProperties.$loaded().then(function() {
                _eventProperties = inputEventProperties;

                // If this is a multigame event, get the data needed for multigame components.
                if (_eventProperties.format.multiGame) {

                    getGamesList(inputEvent).then(function then(model) {
                        _gameList = model;
                        getFirstPlaceScores();
                    });

                    // Is this a team-based event?
                    if (!_eventProperties.format.teamBased) {

                        getMultiGameLeaderboard(inputEvent).then(function then(model) {
                            var leaderboard = model;
                            _leaderboardLength = leaderboard.length;
                            _summarizedLeaderboard = leaderboard.slice(0, 8);
                        });

                    } else {

                        teamService.getTeamList(inputEvent).then(function then(model) {
                            _teamList = model;

                            getTeamBasedMultiGamePlayerLeaderboard(inputEvent).then(function then(model) {
                                var leaderboard = model;
                                _leaderboardLength = leaderboard.length;
                                _summarizedLeaderboard = leaderboard.slice(0, 8);
                            });

                            getTeamLeaderboard(inputEvent).then(function then(model) {
                                var leaderboard = model;
                                _teamLeaderboardLength = leaderboard.length;
                                _teamSummarizedLeaderboard = leaderboard.slice(0, 8);
                            });
                        });

                    }

                // If this is a single game event, get the data needed for single game components.
                } else {

                    getSingleGameLeaderboard(inputEvent).then(function then(model) {
                        var leaderboard = model;
                        _leaderboardLength = leaderboard.length;
                        _summarizedLeaderboard = leaderboard;
                    });

                }

                // If this is a team-based event, get the data needed for team event components.
                if (_eventProperties.format.teamBased) {

                    teamService.getTeamList(inputEvent).then(function then(model) {
                        _teamList = model;
                    });

                }

            });

        }

        function submitTeamBasedRegistration(inputEvent, inputTeamObject, inputUID, inputUsername) {

            var ref = new Firebase(FIREBASEDATA.FBURL);
            
            var eventData = $firebaseObject(
                ref
                    .child('contests')
                    .child(inputEvent)
            );

            var teamPlayers = $firebaseObject(
                ref
                    .child('contests')
                    .child(inputEvent)
                    .child('teamPool')
                    .child(inputTeamObject.$id)
                    .child('players')
            );

            var profilePledgedData = $firebaseObject(
                ref
                    .child('users')
                    .child(inputUID)
                    .child('pledgedTo')
            );

            eventData.$loaded().then(function() {

                eventData.playerPool[inputUID] = {
                    status: 'active',
                    team: inputTeamObject.$id,
                    userName: inputUsername
                };

                eventData.$save();

            });

            teamPlayers.$loaded().then(function() {

                teamPlayers[inputUsername] = true;
                teamPlayers.$save();

            });

            profilePledgedData.$loaded().then(function() {
                profilePledgedData[inputEvent] = true;
                profilePledgedData.$save();
            });

            Materialize.toast('You are now registered for IGBY2.', 4000);

        }

        function submitTeamMultiGameScore(inputEvent, inputGame, inputTeam, inputScore, inputTwitchUrl, inputScreenshotUrl, inputInpUrl, inputMameVersion) {

            return $q(function(resolve, reject) {

                var ref = new Firebase(FIREBASEDATA.FBURL);

                var userGameScore = $firebaseObject(
                    ref
                        .child('contests')
                        .child(inputEvent)
                        .child('activeGames')
                        .child(inputGame.$id)
                        .child('scores')
                );

                userGameScore.$loaded().then(function() {

                    // Prompt http(s) removal.
                    // FIXME: Handle this automatically. This is half-assed for the time being.
                    if (inputTwitchUrl) {
                        if (inputTwitchUrl.indexOf('http') !== -1) {
                            Materialize.toast('Please remove http:// or https:// from your link.', 4000);
                            reject('invalid');
                            return;
                        }
                    }

                    if (inputInpUrl) {
                        if (inputInpUrl.indexOf('http') !== -1) {
                            Materialize.toast('Please remove http:// or https:// from your link.', 4000);
                            reject('invalid');
                            return;
                        }
                    }

                    if (inputScreenshotUrl) {
                        if (inputScreenshotUrl.indexOf('http') !== -1) {
                            Materialize.toast('Please remove http:// or https:// from your link.', 4000);
                            reject('invalid');
                            return;
                        }
                    }

                    userGameScore[$rootScope.profile.userName] = {
                        score: Number(inputScore),
                        userName: $rootScope.profile.userName,
                        twitchUrl: inputTwitchUrl ? inputTwitchUrl : null,
                        inpUrl: inputInpUrl ? inputInpUrl : null,
                        mameVersion: inputMameVersion ? inputMameVersion : null,
                        screenshotUrl: inputScreenshotUrl ? inputScreenshotUrl : null,
                        team: inputTeam
                    };

                    userGameScore.$save();
                    Materialize.toast('Your score was submitted!', 4000);
                    resolve();

                    // TODO: Add to recent activity.

                });

            });

        }

    }
    eventService.$inject = ["$q", "$filter", "$rootScope", "$firebaseObject", "$firebaseArray", "FIREBASEDATA", "teamService"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .controller('EventMainController', EventMainController);

    /* @ngInject */
    function EventMainController($scope, $rootScope, $filter, $stateParams, $state, $timeout, $firebaseArray, eventService, authService, profileService, teamService, FIREBASEDATA) {

        /* jshint validthis: true */
        var vm = this;

        vm.eventName = $stateParams.eventName;

        vm.addGame = addGame;
        vm.createTeam = createTeam;
        vm.determinePoints = determinePoints;
        vm.goToPlayerProfile = goToPlayerProfile;
        vm.openGameModal = openGameModal;
        vm.openModal = openModal;
        vm.openMultiGameLeaderboardModal = openMultiGameLeaderboardModal;
        vm.openPlayerModal = openPlayerModal;
        vm.openTeamScoresModal = openTeamScoresModal;
        vm.registerForEvent = registerForEvent;
        vm.submitScore = submitScore;

        initEvent();

        /////////////////////////////////

        function addGame() {

            eventService.addGame(vm.eventName, vm.newGame.inputFormalGameName, vm.newGame.inputMameRomset, vm.newGame.inputRules).then(function then(model) {

                vm.newGame.inputFormalGameName = null;
                vm.newGame.inputMameRomset = null;
                vm.newGame.inputRules = null;

                Materialize.toast('Game added.', 4000);

            });

        }

        function calculateTeamScores() {

            var sortedScores = $filter('orderBy')(vm.gameScores, '-score');
            var teamTracker = {};
            var potentialPoints = (vm.teamList.length * 5);

            sortedScores.forEach(function(gameScore) {
                
                if (!teamTracker[gameScore.team]) {
                    teamTracker[gameScore.team] = 1;
                } else {
                    teamTracker[gameScore.team] += 1;
                }

                // We only care about a team's top five scores.
                if (teamTracker[gameScore.team] <= 5) {
                    
                    gameScore.points = potentialPoints;
                    if (potentialPoints > 0) { potentialPoints -= 1; }

                } else {
                    gameScore.points = 0;
                }

            });

        }

        function closeModal() {
            angular.element('.modal').closeModal();
        }

        function createTeam() {
            teamService.createTeam(vm.eventName, vm.newTeam).then(function() {
                Materialize.toast('Team ' + vm.newTeam.shortName + ' created.', 4000);
                vm.newTeam = null;
            });
        }

        function determinePoints(inputScoreData, inputIndex) {

            var userGamePoints;

            // No position greater than 12 gets points.
            if (inputIndex > 11) {
                userGamePoints = 0;
                return userGamePoints;
            }

            userGamePoints = 12 - inputIndex;

            var sortedScores = $filter('orderBy')(vm.gameScores, '-score');

            // Am I tied with the person above me? If so, match their points.
            if (sortedScores[inputIndex - 1]) {

                if (sortedScores[inputIndex - 1].score === inputScoreData.score) {
                    userGamePoints += 1;
                }
            }

            return userGamePoints;

        }

        function goToPlayerProfile(inputPlayer) {

            closeModal();
            $state.go('profile', {username: inputPlayer});

        }

        function initEvent() {

            eventService.loadEventProperties(vm.eventName);

            profileService.getAvatarData().then(function then(model) {
                vm.avatarData = model;
            });

            $scope.$watchCollection(function() { return eventService.getEventPropertiesObject(); }, function(model) {
                vm.eventProperties = model;
            }, true);

            $scope.$watchCollection(function() { return eventService.getTeamListObject(); }, function(model) {
                vm.teamList = model;
            }, true);

            // FIXME: Remove when multi-game submit is working...
            $scope.$watchCollection(function() { return eventService.getGameListObject(); }, function(model) {
                vm.gameList = model;
            }, true);

            eventService.getPlayerPool(vm.eventName).then(function then(model) {
                vm.playerPool = model;
            });

            // FIXME: There should be a better way to initialize Materialize.css components.
            $timeout(function() {
                angular.element('ul.tabs').tabs();
                angular.element('select').material_select();
            }, 600);

        }

        function openModal(inputModal) {

            if (inputModal === '#submitModal' && !$rootScope.profile) {
                $state.go('registerOrLogin');
                return;
            }

            if (inputModal === '#submitModal' && !$rootScope.profile.pledgedTo.igby2) {
                Materialize.toast('You must be registered to IGBY2 to submit a score.', 4000);
                return;
            }

            // This will evaluate to true if a Materialize modal is open.
            if (angular.element('#lean-overlay').length === 1) {

                closeModal();
                $timeout(function() {
                    angular.element(inputModal).openModal();
                    angular.element(inputModal + 'Content').scrollTop(0);
                }, 450);

            } else {

                angular.element(inputModal).openModal();
                angular.element(inputModal + 'Content').scrollTop(0);

            }

        }

        function openGameModal(inputGameName) {

            var ref = new Firebase(FIREBASEDATA.FBURL);

            eventService.getGameData(vm.eventName, inputGameName).then(function then(model) {
                vm.gameData = model;

                vm.gameScores = $firebaseArray(
                    ref
                        .child('contests')
                        .child(vm.eventName)
                        .child('activeGames')
                        .child(vm.gameData.$id)
                        .child('scores')
                );

                vm.gameScores.$loaded().then(function() {
                    if (vm.eventProperties.format.teamBased) {
                        calculateTeamScores();
                    }
                })
            });

            openModal('#gameModal');

        }

        function openMultiGameLeaderboardModal() {

            eventService.getTeamBasedMultiGamePlayerLeaderboard(vm.eventName).then(function then(model) {
                vm.completeLeaderboard = model;
            });

            openModal('#multiGameLeaderboardModal');

        }

        function openPlayerModal(inputPlayer) {

            vm.focusPlayer = inputPlayer;

            // FIXME: Make this cleaner.
            if (vm.eventProperties.format.teamBased) {

                eventService.getPlayerTeamScores(vm.eventName, vm.gameList, vm.focusPlayer).then(function then(model) {

                    vm.playerScores = model;
                    if (vm.playerScores.length > 0) {
                        vm.teamList.forEach(function(team) {
                            if (team.$id === vm.playerScores[0].team) {
                                vm.playerTeam = team.fullName;
                            }
                        });
                    }

                });

            } else {

                eventService.getPlayerScores(vm.eventName, vm.gameList, vm.focusPlayer).then(function then(model) {
                    vm.playerScores = model;
                });

            }

            openModal('#playerModal');

        }

        function openTeamScoresModal(inputTeam) {

            vm.focusTeam = inputTeam;

            eventService.getTeamGameScores(vm.eventName, vm.focusTeam.key).then(function then(model) {
                vm.teamScores = model;
            });

            openModal('#teamScoresModal');

        }

        function registerForEvent() {

            if (vm.regForm.$valid) {

                // Disable the register button.
                vm.disableRegisterButton = true;
                
                if (vm.eventProperties.format.teamBased) {
                    eventService.submitTeamBasedRegistration(vm.eventName, vm.selectedRegTeam, $rootScope.profile.$id, $rootScope.profile.userName);
                } else {
                    // TODO: Registration for non team-based events.
                }

            }

        }

        function submitScore() {

            if (!vm.submitTwitchUrl && !vm.submitScreenshotUrl && !vm.submitInpUrl) {
                Materialize.toast('At least one form of evidence is required.', 4000);
                return;
            }

            if (vm.scoreSubmitForm.$valid) {

                if (vm.eventProperties.format.teamBased && vm.eventProperties.format.multiGame) {
                    eventService.submitTeamMultiGameScore(vm.eventName,
                                                          vm.submitSelectedGame, 
                                                          vm.playerPool[$rootScope.profile.$id].team, 
                                                          vm.submitUserScore, 
                                                          vm.submitTwitchUrl, 
                                                          vm.submitScreenshotUrl, 
                                                          vm.submitInpUrl, 
                                                          vm.submitInpMameVersion)
                        .then(function then(model) {
                            $timeout(function() {
                                closeModal();
                            }, 300);
                        });
                }

            } else {
                Materialize.toast('Please be sure all required information is filled out.', 4000);
            }

        }

    }
    EventMainController.$inject = ["$scope", "$rootScope", "$filter", "$stateParams", "$state", "$timeout", "$firebaseArray", "eventService", "authService", "profileService", "teamService", "FIREBASEDATA"];

})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .service('teamService', teamService);

    /* @ngInject */
    function teamService($q, $firebaseArray, $firebaseObject, FIREBASEDATA) {

    	this.createTeam = createTeam;
        this.getTeamList = getTeamList;

        ////////////////

        function createTeam(inputEvent, inputNewTeamProperties) {

        	var deferred = $q.defer();

        	var ref = new Firebase(FIREBASEDATA.FBURL);
        	var teamPool = $firebaseObject(
        		ref
        			.child('contests')
        			.child(inputEvent)
        			.child('teamPool')
        	);

        	teamPool.$loaded().then(function() {

        		teamPool[inputNewTeamProperties.shortName] = {
        			fullName: inputNewTeamProperties.formalName
        		};
        		teamPool.$save();
        		deferred.resolve();

        	});

        	return deferred.promise;

        }

        function getTeamList(inputEvent) {

        	var deferred = $q.defer();

        	var ref = new Firebase(FIREBASEDATA.FBURL);
        	var teamList = $firebaseArray(
        		ref
        			.child('contests')
        			.child(inputEvent)
        			.child('teamPool')
        	);

        	teamList.$loaded().then(function() {
        		deferred.resolve(teamList);
        	});

        	return deferred.promise;

        }
    }
    teamService.$inject = ["$q", "$firebaseArray", "$firebaseObject", "FIREBASEDATA"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .directive('vgGamesList', vgGamesList);

    /* @ngInject */
    function vgGamesList () {
        var directive = {
            bindToController: true,
            controller: GamesListController,
            controllerAs: 'vm',
            restrict: 'E',
            templateUrl: './app/eventComponents/gamesList.directive.htm',
            scope: false,
            transclude: false
        };
        return directive;
    }

    /* @ngInject */
    function GamesListController($scope, eventService) {
        /* jshint validthis: true */
    	var vm = this;

        $scope.$watchCollection(function() { return eventService.getGameListObject(); }, function(model) {
            $scope.$parent.$parent.event.gameList = model;
        }, true);
    }
    GamesListController.$inject = ["$scope", "eventService"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .directive('vgMultiGameLeaderboard', vgMultiGameLeaderboard);

    /* @ngInject */
    function vgMultiGameLeaderboard () {
        var directive = {
            bindToController: true,
            controller: MultiGameLeaderboardController,
            controllerAs: 'vm',
            restrict: 'E',
            templateUrl: './app/eventComponents/multiGameLeaderboard.directive.htm',
            scope: false,
            transclude: false
        };
        return directive;
    }

    /* @ngInject */
    function MultiGameLeaderboardController($scope, eventService) {
        /* jshint validthis: true */
    	var vm = this;

        $scope.$watchCollection(function() { return eventService.getLeaderboardLengthValue(); }, function(model) {
            $scope.$parent.$parent.event.leaderboardLength = model;
        }, true);

        $scope.$watchCollection(function() { return eventService.getSummarizedLeaderboardObject(); }, function(model) {
            $scope.$parent.$parent.event.summarizedLeaderboard = model;
        }, true);
    }
    MultiGameLeaderboardController.$inject = ["$scope", "eventService"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .directive('vgRulesDisplay', vgRulesDisplay);

    /* @ngInject */
    function vgRulesDisplay() {
        var directive = {
            bindToController: true,
            controller: RulesDisplayController,
            controllerAs: 'vm',
            restrict: 'E',
            templateUrl: './app/eventComponents/rulesDisplay.directive.htm',
            scope: false,
            transclude: false
        };
        return directive;
    }

    /* @ngInject */
    function RulesDisplayController($timeout) {
        /* jshint validthis: true */
    	var vm = this;

        // FIXME: This is a temporary hack. Initialize the Materialize.css dropdowns after the component is loaded.
        $timeout(function() {
            angular.element('.collapsible').collapsible({
                accordion: false
            });
        }, 600);
    }
    RulesDisplayController.$inject = ["$timeout"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .directive('vgSingleGameLeaderboard', vgSingleGameLeaderboard);

    /* @ngInject */
    function vgSingleGameLeaderboard () {
        var directive = {
            bindToController: true,
            controller: SingleGameLeaderboardController,
            controllerAs: 'vm',
            restrict: 'E',
            templateUrl: './app/eventComponents/singleGameLeaderboard.directive.htm',
            scope: false,
            transclude: false
        };
        return directive;
    }

    /* @ngInject */
    function SingleGameLeaderboardController($scope, eventService) {
        /* jshint validthis: true */
    	var vm = this;

        $scope.$watchCollection(function() { return eventService.getLeaderboardLengthValue(); }, function(model) {
            $scope.$parent.$parent.event.leaderboardLength = model;
        }, true);

        $scope.$watchCollection(function() { return eventService.getSummarizedLeaderboardObject(); }, function(model) {
            $scope.$parent.$parent.event.summarizedLeaderboard = model;
        }, true);
    }
    SingleGameLeaderboardController.$inject = ["$scope", "eventService"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .directive('vgStickyMessage', vgStickyMessage);

    /* @ngInject */
    function vgStickyMessage () {
        var directive = {
            bindToController: true,
            controller: StickyMessageController,
            controllerAs: 'vm',
            restrict: 'E',
            templateUrl: './app/eventComponents/stickyMessage.directive.htm',
            scope: {
            	properties: '='
            }
        };
        return directive;
    }

    /* @ngInject */
    function StickyMessageController($timeout) {
        /* jshint validthis: true */
    	var vm = this;
    }
    StickyMessageController.$inject = ["$timeout"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .directive('vgStreamerList', vgStreamerList);

    /* @ngInject */
    function vgStreamerList() {
        var directive = {
            bindToController: true,
            controller: StreamerListController,
            controllerAs: 'vm',
            restrict: 'E',
            templateUrl: './app/eventComponents/streamerList.directive.htm',
            scope: false,
            transclude: false
        };
        return directive;
    }

    /* @ngInject */
    function StreamerListController($scope, $http, $interval, $timeout, $firebaseArray, $firebaseObject, eventService, FIREBASEDATA) {
        /* jshint validthis: true */
    	var vm = this;

        vm.buildStreamerList = buildStreamerList;

        activate();

        //////////////////////

        function activate() {

            $timeout(function() {

                buildStreamerList();

            }, 2000);

        }

        function buildStreamerList() {

            var ref = new Firebase(FIREBASEDATA.FBURL);
            vm.activeStreamerList = [];

            vm.igby2PlayerPoolArray = $firebaseArray(
                ref
                    .child('contests')
                    .child('igby2')
                    .child('playerPool')
            );

            vm.activeStreamerList = [];
            vm.igby2PlayerPoolArray.$loaded().then(function() {

                // Iterate through the player pool and build the streamer list array.
                vm.igby2PlayerPoolArray.forEach(function(element) {

                    var playerRef = $firebaseObject(
                        ref
                            .child('users')
                            .child(element.$id)
                    );

                    playerRef.$loaded().then(function() {
                        if (playerRef.twitch) {

                            $http
                                .jsonp('https://api.twitch.tv/kraken/streams/' + playerRef.twitch + '?callback=JSON_CALLBACK')
                                .success(function(data) {

                                    // If there is stream data, the user must be live. Add them to our list to display.
                                    if (data.stream) {
                                        vm.activeStreamerList.push({
                                            userName: playerRef.userName,
                                            twitch: playerRef.twitch,
                                            team: element.team
                                        });
                                    }

                                });

                        }
                    });

                });

            });

        }


    }
    StreamerListController.$inject = ["$scope", "$http", "$interval", "$timeout", "$firebaseArray", "$firebaseObject", "eventService", "FIREBASEDATA"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .directive('vgTeamPlayerLeaderboard', vgTeamPlayerLeaderboard);

    /* @ngInject */
    function vgTeamPlayerLeaderboard() {
        var directive = {
            bindToController: true,
            controller: TeamPlayerLeaderboardController,
            controllerAs: 'vm',
            restrict: 'E',
            templateUrl: './app/eventComponents/teamPlayerLeaderboard.directive.htm',
            scope: false,
            transclude: false
        };
        return directive;
    }

    /* @ngInject */
    function TeamPlayerLeaderboardController($scope, eventService) {
        /* jshint validthis: true */
    	var vm = this;

        $scope.$watchCollection(function() { return eventService.getLeaderboardLengthValue(); }, function(model) {
            $scope.$parent.$parent.event.leaderboardLength = model;
        }, true);

        $scope.$watchCollection(function() { return eventService.getSummarizedLeaderboardObject(); }, function(model) {
            $scope.$parent.$parent.event.summarizedLeaderboard = model;
        }, true);
    }
    TeamPlayerLeaderboardController.$inject = ["$scope", "eventService"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .directive('vgTeamTeamsLeaderboard', vgTeamTeamsLeaderboard);

    /* @ngInject */
    function vgTeamTeamsLeaderboard() {
        var directive = {
            bindToController: true,
            controller: TeamTeamsLeaderboardController,
            controllerAs: 'vm',
            restrict: 'E',
            templateUrl: './app/eventComponents/teamTeamsLeaderboard.directive.htm',
            scope: false,
            transclude: false
        };
        return directive;
    }

    /* @ngInject */
    function TeamTeamsLeaderboardController($scope, eventService) {
        /* jshint validthis: true */
    	var vm = this;

    	$scope.$watchCollection(function() { return eventService.getTeamLeaderboardLengthValue(); }, function(model) {
            $scope.$parent.$parent.event.teamLeaderboardLength = model;
        }, true);

        $scope.$watchCollection(function() { return eventService.getTeamSummarizedLeaderboardObject(); }, function(model) {
            $scope.$parent.$parent.event.teamSummarizedLeaderboard = model;
        }, true);
    }
    TeamTeamsLeaderboardController.$inject = ["$scope", "eventService"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .controller('HeaderController', HeaderController);

    /* @ngInject */
    function HeaderController($timeout, $rootScope, $window, $state, authService) {

        /* jshint validthis: true */
        var vm = this;
        vm.logOut = logOut;

        activate();

        //////////////////////////

        function activate() {
            // FIXME: Materialize and AngularJS do not play nicely together. If the dropdown is
            //        initialized before all content has been rendered, the dropdown will not actually work.
            //        This is a messy hack for the time being, but revisit this later.
            $timeout(function() {
                angular.element('.dropdown-button')
                    .dropdown({
                        inDuration: 300,
                        outDuration: 225,
                        constrain_width: false,
                        hover: false,
                        gutter: -114,
                        belowOrigin: true
                    });
            }, 400);

            $timeout(function() {
                angular.element('.dropdown-button')
                    .dropdown({
                        inDuration: 300,
                        outDuration: 225,
                        constrain_width: false,
                        hover: false,
                        gutter: -114,
                        belowOrigin: true
                    });
            }, 1000);
        }

        function logOut() {
            authService.logOut();
            $window.location.reload();
        }

    }
    HeaderController.$inject = ["$timeout", "$rootScope", "$window", "$state", "authService"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .directive('numbersOnly', numbersOnly);

    /* @ngInject */
    function numbersOnly() {
        return {
            require: 'ngModel',
            link: function (scope, element, attr, ngModelCtrl) {
                function fromUser(text) {
                    if (text) {
                        var transformedInput = text.replace(/[^0-9-]/g, '');

                        if (transformedInput !== text) {
                            ngModelCtrl.$setViewValue(transformedInput);
                            ngModelCtrl.$render();
                        }
                        return transformedInput;
                    }
                    return undefined;
                }            
                ngModelCtrl.$parsers.push(fromUser);
            }
        };
    }
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .filter('orderObjectBy', orderObjectBy);

    function orderObjectBy() {
        return function(items, field, reverse) {
            var filtered = [];

            angular.forEach(items, function(item, key) {
                item.key = key;
                filtered.push(item);
            });

            filtered.sort(function (a, b) {
                return (a[field] > b[field] ? 1 : -1);
            });

            if(reverse) filtered.reverse();

            return filtered;
        };
    }

})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .controller('AvatarController', AvatarController);

    /* @ngInject */
    function AvatarController($rootScope, $state, $stateParams, $timeout, Upload, imgur, profileService) {

        /* jshint validthis: true */
        var vm = this;
        vm.uploadAvatar = uploadAvatar;

        activate();

        ////////////////

        function activate() {
        	profileService.getAvatarData().then(function then(model) {
                vm.avatarData = model;
            });

            // FIXME: This needs to be triggered by a $rootScope broadcast of when it receives profile data.
            $timeout(function() {
                profileService.getBadgesData($rootScope.profile.userName).then(function then(model) {
                    vm.badgesData = model;
                });
            }, 500);
        }

        function uploadAvatar() {

        	vm.disableButton = true;

        	imgur.setAPIKey('Client-ID f53d6d5833b07bc');
        	imgur.upload(vm.file).then(function then(model) {
        		profileService.saveAvatarLink(model[0].link, $rootScope.profile.userName);
        		Materialize.toast('Your avatar was uploaded', 4000);

        		$timeout(function() {
        			$state.go('home');
        		}, 1000);
        	});

        }

    }
    AvatarController.$inject = ["$rootScope", "$state", "$stateParams", "$timeout", "Upload", "imgur", "profileService"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .controller('ChangePasswordController', ChangePasswordController);

    /* @ngInject */
    function ChangePasswordController($scope, $timeout, $state, AuthWrapper) {

        /* jshint validthis: true */
        var vm = this;
        
        vm.submitChangePassword = submitChangePassword;

        //////////////////

        function submitChangePassword() {

            if ($scope.pwChangeForm.$valid) {

                AuthWrapper.$changePassword({
                    email: AuthWrapper.$getAuth().password.email,
                    oldPassword: vm.inputCurrentPassword,
                    newPassword: vm.inputNewPassword
                }).then(function() {

                    Materialize.toast('Your password was changed.', 4000);
                    $timeout(function() {
                        $state.go('home');
                    }, 1000);

                }).catch(function(error) {
                    
                    if (error.code === 'INVALID_PASSWORD') {
                        vm.showChangePasswordMessage = true;
                    }

                });

            }

        }

    }
    ChangePasswordController.$inject = ["$scope", "$timeout", "$state", "AuthWrapper"];

})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .controller('HomeController', HomeController);

    /* @ngInject */
    function HomeController($scope, $timeout) {

        /* jshint validthis: true */
        var vm = this;

        ////////////////////////

    }
    HomeController.$inject = ["$scope", "$timeout"];

})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .controller('LeaderboardController', LeaderboardController);

    /* @ngInject */
    function LeaderboardController($q, $timeout, $firebaseArray, profileService, FIREBASEDATA) {

        /* jshint validthis: true */
    	var vm = this;

        activate();

        ////////////////

        function activate() {
            getProfileScores().then(function then(model) {
                vm.profileScoreData = model;
            });

            profileService.getAvatarData().then(function then(model) {
                vm.avatarData = model;
            });
        }

        function getProfileScores() {

        	var deferred = $q.defer();
        	var ref = new Firebase(FIREBASEDATA.FBURL);

        	var profileScoreData = $firebaseArray(
        		ref
        			.child('badges')
        	);

        	profileScoreData.$loaded(function() {
        		deferred.resolve(profileScoreData);
        	});

        	return deferred.promise;

        }

    }
    LeaderboardController.$inject = ["$q", "$timeout", "$firebaseArray", "profileService", "FIREBASEDATA"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .controller('ProfileController', ProfileController);

    /* @ngInject */
    function ProfileController($scope, $stateParams, $q, $timeout, $state, $firebaseArray, authService, profileService, eventService) {

        /* jshint validthis: true */
        var vm = this;
        
        activate();

        /////////////////////////////////

        function activate() {

            profileService.getUserData($stateParams.username).then(function then(model) {
                vm.profileData = model;

                profileService.getTournamentHistory(vm.profileData).then(function then(model) {
                    var tournamentHistoryData = model;
                    vm.eventStandings = profileService.getTournamentStandings(tournamentHistoryData, $stateParams.username);
                });
            });

            profileService.getAvatarData().then(function then(model) {
                vm.avatarData = model;
            });

            profileService.getBadgesData($stateParams.username).then(function then(model) {
                vm.badgesData = model;

                $timeout(function() {

                    angular.element('.collapsible').collapsible({
                        accordion: true
                    });

                }, 200);
            });

        }

    }
    ProfileController.$inject = ["$scope", "$stateParams", "$q", "$timeout", "$state", "$firebaseArray", "authService", "profileService", "eventService"];

})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .service('profileService', profileService);

    /* @ngInject */
    function profileService($rootScope, $q, $firebaseArray, $firebaseObject, eventService, FIREBASEDATA) {

    	this.getAvatarData = getAvatarData;
        this.getBadgesData = getBadgesData;
    	this.getTournamentHistory = getTournamentHistory;
        this.getTournamentStandings = getTournamentStandings;
        this.getUserData = getUserData;
        this.saveAvatarLink = saveAvatarLink;

        ////////////////

        function getAvatarData() {

            var deferred = $q.defer();
            var ref = new Firebase(FIREBASEDATA.FBURL);

            var avatarData = $firebaseObject(
                ref
                    .child('avatars')
            );

            avatarData.$loaded(function() {
                deferred.resolve(avatarData);
            });

            return deferred.promise;

        }

        function getBadgesData(inputUser) {

            var deferred = $q.defer();
            var ref = new Firebase(FIREBASEDATA.FBURL);

            var badgesData = $firebaseObject(
                ref
                    .child('badges')
                    .child(inputUser)
            );

            badgesData.$loaded(function() {
                deferred.resolve(badgesData);
            });

            return deferred.promise;

        }

        function getTournamentHistory(inputUserData) {

        	var deferred = $q.defer();
        	var ref = new Firebase(FIREBASEDATA.FBURL);

        	// Loop through each event in the pledgedTo object.
        	var eventsArray = [];
        	for (var key in inputUserData.pledgedTo) {
        		eventsArray.push(key);
        	}

        	deferred.resolve(eventsArray);

        	return deferred.promise;

        }

        function getTournamentStandings(inputTournamentHistory, inputUser) {

            var ref = new Firebase(FIREBASEDATA.FBURL);

            // Loop through each event in the user's history.
            var eventStandings = [];
            inputTournamentHistory.forEach(function(event) {

                eventService.getEventProperties(event).then(function(eventProperties) {

                    eventProperties.$loaded().then(function() {

                        // If concluded, get the user's standing.
                        if (eventProperties.state === 'concluded') {

                            var eventStandingData = $firebaseObject(
                                ref
                                    .child('standings')
                                    .child(event)
                            );

                            eventStandingData.$loaded().then(function() {

                                if (eventStandingData[inputUser]) {

                                    eventStandings.push({
                                        name: eventProperties.name,
                                        premier: eventProperties.premier ? true : null,
                                        shortName: event,
                                        state: 'concluded',
                                        color: eventProperties.color,
                                        position: eventStandingData[inputUser]
                                    });

                                } else {

                                    eventStandings.push({
                                        name: eventProperties.name,
                                        premier: eventProperties.premier ? true : null,
                                        shortName: event,
                                        state: 'concluded',
                                        color: eventProperties.color,
                                        position: -1
                                    });

                                }

                            });

                        } else if (eventProperties.state === 'inprogress' || eventProperties.state === 'upcoming') {

                            eventStandings.push({
                                name: eventProperties.name,
                                premier: eventProperties.premier ? true : null,
                                shortName: event,
                                color: eventProperties.color,
                                state: eventProperties.state
                            });

                        }

                    });

                });

            });

            return eventStandings;

        }

        function getUserData(inputUser) {

        	var deferred = $q.defer();
        	var ref = new Firebase(FIREBASEDATA.FBURL);

        	var usersData = $firebaseArray(
        		ref
        			.child('users')
        	);

        	usersData.$loaded(function() {

        		usersData.forEach(function(user) {
        			if (user.userName === inputUser) {
        				deferred.resolve(user);
        			}
        		});

        	});

        	return deferred.promise;

        }

        // FIXME: Make this server-side.
        function saveAvatarLink(inputLink, inputUser) {
            
            var ref = new Firebase(FIREBASEDATA.FBURL);

            var avatarData = $firebaseObject(
                ref
                    .child('avatars')
            );

            avatarData.$loaded(function() {
                avatarData[inputUser] = inputLink;
                avatarData.$save();
            });

        }

    }
    profileService.$inject = ["$rootScope", "$q", "$firebaseArray", "$firebaseObject", "eventService", "FIREBASEDATA"];
})();;(function() {
    'use strict';

    angular
        .module('vg.app')
        .controller('RegController', RegController);

    /* @ngInject */
    function RegController($scope, $rootScope, $timeout, $window, $state, $firebaseObject, authService, AuthWrapper) {

        /* jshint validthis: true */
        var vm = this;

        vm.loginToAccount = loginToAccount;
        vm.passwordReset = passwordReset;
        vm.submitNewAccount = submitNewAccount;

        /////////////////////

        function loginToAccount() {

            authService.loginToAccount(vm.loginEmail, vm.loginPassword).then(function then(model) {

                vm.showInvalidUserError = false;
                vm.showInvalidPasswordError = false;

                if (model === 'LOGIN_SUCCESS') {

                    $state.go('home');

                } else if (model === 'INVALID_USER') {
                    vm.showInvalidUserError = true;
                    return;
                } else if (model === 'INVALID_PASSWORD') {
                    vm.showInvalidPasswordError = true;
                }

            });

        }

        function passwordReset() {

            if (!vm.loginEmail) {
                vm.showPasswordResetEmailMessage = true;
                return;
            }

            AuthWrapper.$resetPassword({
                email: vm.loginEmail
            }).then(function() {
                vm.showPasswordResetEmailMessage = false;
                Materialize.toast('A password reset email has been sent to ' + vm.loginEmail + '.', 4000);
            });

        }

        function submitNewAccount() {
            
            // Does the user exist? If so, show an error message.
            authService.checkIfUserExists(vm.newUsername).then(function(userExists) {

                vm.showDuplicateUserError = false;
                vm.showEmailTakenError = false;

                if (userExists) {

                    vm.showDuplicateUserError = true;
                    return;

                // Try to create the new user.
                } else {

                    authService.createNewUser(vm.newEmail, vm.newPassword, vm.newUsername).then(function then(model) {

                        if (model === 'EMAIL_TAKEN') {

                            vm.showEmailTakenError = true;
                            return;

                        } else if (model === 'ACCOUNT_CREATED') {

                            $state.go('profile', {username: vm.newUsername});

                        }

                    });

                }

            });

        }

    }
    RegController.$inject = ["$scope", "$rootScope", "$timeout", "$window", "$state", "$firebaseObject", "authService", "AuthWrapper"];

})();